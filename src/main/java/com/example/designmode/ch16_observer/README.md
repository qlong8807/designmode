>JDK中提供了:java.util.Observable实现类和java.util.Observer接口， 也就是说
我们上面写的那个例子中的Observable接口可以改换成java.util.Observale实现类

观察者模式（Observer Pattern） 也叫做发布订阅模式（Publish/subscribe） ,它是一个在项
目中经常使用的模式， 其定义如下：
>Define a one-to-many dependency between objects so that when one object changes state,all its
dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系， 使得每
当一个对象改变状态， 则所有依赖于它的对象都会得到通知并被自动更新。 ）



# 观察者模式的优点
* 观察者和被观察者之间是抽象耦合

# 观察者模式的缺点
>观察者模式需要考虑一下开发效率和运行效率问题， 一个被观察者， 多个观察者， 开发
  和调试就会比较复杂， 而且在Java中消息的通知默认是顺序执行， 一个观察者卡壳， 会影响
  整体的执行效率。 在这种情况下， 一般考虑采用异步的方式。

# 观察者模式的使用场景
* 关联行为场景。 需要注意的是， 关联行为是可拆分的， 而不是“组合”关系。
* 事件多级触发场景。
* 跨系统的消息交换场景， 如消息队列的处理机制。

# 观察者模式的注意事项
  使用观察者模式也有以下两个重点问题要解决。
* 广播链的问题
>如果你做过数据库的触发器， 你就应该知道有一个触发器链的问题， 比如表A上写了一
  个触发器， 内容是一个字段更新后更新表B的一条数据， 而表B上也有个触发器， 要更新表
  C， 表C也有触发器……完蛋了， 这个数据库基本上就毁掉了！ 我们的观察者模式也是一样
  的问题， 一个观察者可以有双重身份， 既是观察者， 也是被观察者， 这没什么问题呀， 但是
  链一旦建立， 这个逻辑就比较复杂， 可维护性非常差， 根据经验建议， 在一个观察者模式中
  最多出现一个对象既是观察者也是被观察者， 也就是说消息最多转发一次（传递两次） ， 这
  还是比较好控制的。
* 异步处理问题
>如果观察者比较多， 而且处理时间比较长怎么办？ 那就用异步.

